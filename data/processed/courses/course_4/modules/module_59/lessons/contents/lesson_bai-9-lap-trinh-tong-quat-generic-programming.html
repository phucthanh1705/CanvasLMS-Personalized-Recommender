<h1>BÀI 9 – LẬP TRÌNH TỔNG QUÁT (GENERIC PROGRAMMING)</h1><h2>Mục tiêu học tập</h2><ul><li>Hiểu khái niệm Generic Programming và lý do Java hỗ trợ generic từ phiên bản 5.</li><li>Biết cách định nghĩa lớp, phương thức và interface tổng quát.</li><li>Phân biệt Generic với Object, hiểu cơ chế type erasure của JVM.</li><li>Ứng dụng Generic trong Collection Framework (List, Set, Map) và phương thức Template Method.</li></ul><hr><h2>1. Giới thiệu lập trình tổng quát</h2><p><b>Lập trình tổng quát (Generic Programming)</b> cho phép viết mã độc lập với kiểu dữ liệu cụ thể, tăng khả năng tái sử dụng và đảm bảo an toàn kiểu.</p><pre><code>class Box { private T value; void set(T v){ value=v; } T get(){ return value; } }</code></pre><p><code>T</code> là tham số kiểu (type parameter) được thay bằng kiểu cụ thể khi sử dụng.</p><pre><code>Box b1 = new Box&lt;&gt;(); b1.set(10); System.out.println(b1.get());</code></pre><hr><h2>2. Lợi ích của Generic</h2><ul><li>Phát hiện lỗi kiểu dữ liệu tại compile-time thay vì runtime.</li><li>Tái sử dụng mã cho nhiều loại dữ liệu khác nhau.</li><li>Không cần ép kiểu khi lấy dữ liệu từ Collection.</li></ul><pre><code>List list = new ArrayList&lt;&gt;(); list.add("Java"); String s = list.get(0);</code></pre><hr><h2>3. Định nghĩa lớp và phương thức tổng quát</h2><h3>3.1. Lớp tổng quát</h3><pre><code>class Pair { K key; V value; Pair(K k,V v){ key=k; value=v; } K getKey(){ return key; } V getValue(){ return value; } }</code></pre><h3>3.2. Phương thức tổng quát</h3><pre><code>public static  void printArray(T[] arr){ for(T item: arr) System.out.print(item+" "); }</code></pre><p>Phương thức trên có thể nhận mảng của bất kỳ kiểu dữ liệu nào.</p><hr><h2>4. Giới hạn kiểu (Bounded Type Parameters)</h2><p>Cho phép ràng buộc kiểu generic để chỉ nhận các lớp con của một lớp nhất định.</p><pre><code>class Stats { T[] nums; Stats(T[] n){ nums=n; } double average(){ double sum=0; for(T x: nums) sum += x.doubleValue(); return sum/nums.length; } }</code></pre><p>Chỉ chấp nhận kiểu Number hoặc các lớp con như Integer, Double, Float,...</p><hr><h2>5. Wildcards trong Generic</h2><p>Wildcard <code>?</code> đại diện cho một kiểu không xác định.</p><pre><code>List list = new ArrayList();</code></pre><p>Các dạng phổ biến:</p><ul><li><b>Unbounded (? )</b>: không giới hạn kiểu.</li><li><b>Upper-bounded (? extends T)</b>: giới hạn trên.</li><li><b>Lower-bounded (? super T)</b>: giới hạn dưới.</li></ul><pre><code>static double sum(List nums){ double s=0; for(Number n: nums) s+=n.doubleValue(); return s; }</code></pre><hr><h2>6. Type Erasure</h2><p>Generic chỉ tồn tại ở thời điểm biên dịch. JVM xóa bỏ thông tin kiểu tại runtime và thay thế bằng Object hoặc upper bound (nếu có).</p><p>Điều này giúp Java tương thích ngược với các phiên bản cũ nhưng có giới hạn:</p><ul><li>Không thể tạo mảng generic (<code>new T[5]</code> sai cú pháp).</li><li>Không thể kiểm tra instanceof với generic (<code>x instanceof List</code> sai cú pháp).</li></ul><hr><h2>7. Generic trong Collection Framework</h2><p>Generic được sử dụng rộng rãi trong Java Collections:</p><ul><li><code>List</code> – danh sách có thứ tự.</li><li><code>Set</code> – tập hợp không trùng.</li><li><code>Map</code> – ánh xạ khóa-giá trị.</li></ul><pre><code>Map map = new HashMap&lt;&gt;(); map.put(1,"Java"); map.put(2,"Python"); for(Integer k: map.keySet()){ System.out.println(k+":"+map.get(k)); }</code></pre><hr><h2>8. Interface Generic</h2><pre><code>interface Container { void add(T item); T get(int index); }</code></pre><p>Lớp hiện thực interface tổng quát có thể chỉ định kiểu cụ thể hoặc tiếp tục để kiểu tổng quát.</p><hr><h2>9. Template Method và Generic</h2><p>Phương thức Template giúp định nghĩa khung xử lý chung, phần cụ thể được override ở lớp con. Khi kết hợp với generic, có thể tạo cấu trúc linh hoạt và tái sử dụng cao.</p><pre><code>abstract class Processor { abstract void process(T data); void execute(List dataList){ for(T d: dataList) process(d); } }</code></pre><p>Lớp con chỉ cần định nghĩa cách xử lý từng phần tử.</p><hr><h2>10. Ví dụ tổng hợp</h2><pre><code>class Repository { private List items = new ArrayList&lt;&gt;(); void add(T item){ items.add(item); } T get(int i){ return items.get(i); } void showAll(){ for(T t: items) System.out.println(t); } public static void main(String[] args){ Repository r = new Repository&lt;&gt;(); r.add("Java"); r.add("OOP"); r.showAll(); } }</code></pre><hr><h2>Kết luận</h2><p>Generic Programming giúp Java an toàn kiểu hơn, giảm ép kiểu thủ công và tăng khả năng tái sử dụng mã. Việc kết hợp generic với Collection Framework là nền tảng trong lập trình hiện đại.</p>