{
  "id": "lesson_bai-05-cay-nhi-phan",
  "title": "lesson_bai-05-cay-nhi-phan",
  "body": "<h1>üß© B√ÄI 05 ‚Äì C√ÇY NH·ªä PH√ÇN</h1><h2>üéØ M·ª•c ti√™u h·ªçc t·∫≠p</h2><ul><li>Hi·ªÉu kh√°i ni·ªám, ƒë·∫∑c ƒëi·ªÉm v√† c·∫•u tr√∫c d·ªØ li·ªáu c·ªßa c√¢y nh·ªã ph√¢n (Binary Tree).</li><li>N·∫Øm ƒë∆∞·ª£c c√°ch bi·ªÉu di·ªÖn c√¢y, c√°c lo·∫°i node v√† kh√°i ni·ªám b·∫≠c, m·ª©c, chi·ªÅu cao c√¢y.</li><li>Hi·ªÉu c∆° ch·∫ø ho·∫°t ƒë·ªông c·ªßa C√¢y Nh·ªã Ph√¢n T√¨m Ki·∫øm (BST) v√† c√°ch x√¢y d·ª±ng c√¢y t·ª´ d√£y gi√° tr·ªã.</li><li>C√†i ƒë·∫∑t v√† th·ª±c hi·ªán c√°c thao t√°c c∆° b·∫£n: th√™m, duy·ªát, t√¨m ki·∫øm, x√≥a node.</li><li>Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p v√† c√°c tr∆∞·ªùng h·ª£p ƒë·∫∑c bi·ªát c·ªßa BST.</li></ul><hr><h2>1. C·∫•u tr√∫c v√† ƒë·∫∑c ƒëi·ªÉm c·ªßa c√¢y</h2><p>C√¢y l√† t·∫≠p h·ª£p c√°c n√∫t (node) ƒë∆∞·ª£c n·ªëi v·ªõi nhau b·ªüi c√°c c·∫°nh (edge). M·ªói n√∫t c√≥ th·ªÉ c√≥ 0 ho·∫∑c nhi·ªÅu n√∫t con. C√¢y nh·ªã ph√¢n l√† lo·∫°i c√¢y m√† m·ªói n√∫t c√≥ t·ªëi ƒëa 2 n√∫t con: <b>tr√°i</b> v√† <b>ph·∫£i</b>.</p><ul><li>N√∫t g·ªëc (root): kh√¥ng c√≥ n√∫t cha.</li><li>N√∫t l√° (leaf): kh√¥ng c√≥ n√∫t con.</li><li>N√∫t trong (internal): c√≥ √≠t nh·∫•t m·ªôt n√∫t con.</li><li>B·∫≠c c·ªßa n√∫t: s·ªë l∆∞·ª£ng n√∫t con c·ªßa n√∫t ƒë√≥.</li><li>B·∫≠c c·ªßa c√¢y: b·∫≠c l·ªõn nh·∫•t trong c√°c n√∫t.</li><li>M·ª©c c·ªßa n√∫t (level): kho·∫£ng c√°ch t·ª´ g·ªëc ƒë·∫øn n√∫t ƒë√≥.</li><li>Chi·ªÅu cao c·ªßa c√¢y (height): m·ª©c cao nh·∫•t + 1.</li></ul><hr><h2>2. C·∫•u tr√∫c d·ªØ li·ªáu c√¢y nh·ªã ph√¢n</h2><p>M·ªói n√∫t trong c√¢y ƒë∆∞·ª£c m√¥ t·∫£ b·ªüi ba th√†nh ph·∫ßn: d·ªØ li·ªáu (info), con tr·ªè tr√°i (left), con tr·ªè ph·∫£i (right).</p><pre><code>typedef struct tagNode { DataType info; struct tagNode *left; struct tagNode *right; } Node, *PtrNode; PtrNode tree;</code></pre><p>V√≠ d·ª• m√¥ t·∫£ c√¢y nh·ªã ph√¢n v·ªõi 7 node:</p><pre><code>         8      /          5       10   /   \\         1     6       20</code></pre><hr><h2>3. C√¢y Nh·ªã Ph√¢n T√¨m Ki·∫øm (Binary Search Tree ‚Äì BST)</h2><p>BST l√† c√¢y nh·ªã ph√¢n c√≥ t√≠nh ch·∫•t ƒë·∫∑c bi·ªát:</p><ul><li>Gi√° tr·ªã c·ªßa m·ªói node l·ªõn h∆°n t·∫•t c·∫£ c√°c node trong c√¢y con tr√°i.</li><li>Gi√° tr·ªã c·ªßa m·ªói node nh·ªè h∆°n t·∫•t c·∫£ c√°c node trong c√¢y con ph·∫£i.</li></ul><p>Do ƒë√≥, gi√° tr·ªã nh·ªè nh·∫•t n·∫±m ·ªü node tr√°i nh·∫•t, gi√° tr·ªã l·ªõn nh·∫•t ·ªü node ph·∫£i nh·∫•t.</p><h3>C·∫•u tr√∫c khai b√°o BST:</h3><pre><code>typedef struct tagNode { int data; struct tagNode *pLeft, *pRight; } Node, *PtrNode;</code></pre><hr><h2>4. Ch√®n ph·∫ßn t·ª≠ v√†o BST</h2><p><b>Nguy√™n t·∫Øc:</b> N·∫øu c√¢y r·ªóng, node m·ªõi tr·ªü th√†nh g·ªëc. N·∫øu gi√° tr·ªã nh·ªè h∆°n node hi·ªán t·∫°i ‚Üí ch√®n v√†o tr√°i, l·ªõn h∆°n ‚Üí ch√®n v√†o ph·∫£i.</p><pre><code>int InsertNode(PtrNode &amp;t, int x) { if (t != NULL) { if (x == t-&gt;data) return 0; if (x &lt; t-&gt;data) InsertNode(t-&gt;pLeft, x); else InsertNode(t-&gt;pRight, x); } else { t = new Node; if (t == NULL) return -1; t-&gt;data = x; t-&gt;pLeft = t-&gt;pRight = NULL; return 1; } }</code></pre><p>Tr∆∞·ªùng h·ª£p g·∫∑p gi√° tr·ªã tr√πng ‚Üí kh√¥ng ch√®n (return 0).</p><hr><h2>5. Duy·ªát c√¢y</h2><p>C√≥ ba c√°ch duy·ªát c∆° b·∫£n:</p><ul><li><b>PreOrder (NLR):</b> X·ª≠ l√Ω node hi·ªán t·∫°i ‚Üí Duy·ªát tr√°i ‚Üí Duy·ªát ph·∫£i.</li><li><b>InOrder (LNR):</b> Duy·ªát tr√°i ‚Üí X·ª≠ l√Ω node hi·ªán t·∫°i ‚Üí Duy·ªát ph·∫£i.</li><li><b>PostOrder (LRN):</b> Duy·ªát tr√°i ‚Üí Duy·ªát ph·∫£i ‚Üí X·ª≠ l√Ω node hi·ªán t·∫°i.</li></ul><h3>V√≠ d·ª•:</h3><pre><code>void NLR(Tree t) { if (t != NULL) { printf(\"%d \", t-&gt;data); NLR(t-&gt;pLeft); NLR(t-&gt;pRight); } }</code></pre><hr><h2>6. T√¨m ki·∫øm v√† x√≥a node</h2><p><b>T√¨m ki·∫øm:</b> So s√°nh x v·ªõi gi√° tr·ªã node hi·ªán t·∫°i. N·∫øu x nh·ªè h∆°n ‚Üí sang tr√°i, l·ªõn h∆°n ‚Üí sang ph·∫£i. N·∫øu b·∫±ng ‚Üí t√¨m th·∫•y.</p><p><b>X√≥a node:</b> C√≥ ba tr∆∞·ªùng h·ª£p:</p><ol><li>Node l√† l√° ‚Üí x√≥a tr·ª±c ti·∫øp.</li><li>Node c√≥ 1 con ‚Üí thay b·∫±ng node con duy nh·∫•t.</li><li>Node c√≥ 2 con ‚Üí t√¨m node thay th·∫ø (tr√°i nh·∫•t c·ªßa c√¢y con ph·∫£i ho·∫∑c ph·∫£i nh·∫•t c·ªßa c√¢y con tr√°i), g√°n gi√° tr·ªã thay th·∫ø, sau ƒë√≥ x√≥a node thay th·∫ø.</li></ol><pre><code>void Remove(Tree &amp;t, int x) { if (t != NULL) { if (x &lt; t-&gt;data) Remove(t-&gt;pLeft, x); else if (x &gt; t-&gt;data) Remove(t-&gt;pRight, x); else { PtrNode pDel = t; if (t-&gt;pLeft == NULL) t = t-&gt;pRight; else if (t-&gt;pRight == NULL) t = t-&gt;pLeft; else SearchStandFor(pDel, t-&gt;pRight); delete pDel; } } }</code></pre><hr><h2>7. Ph√¢n t√≠ch ƒë·ªô ph·ª©c t·∫°p</h2><p>V·ªõi c√¢y c√≥ chi·ªÅu cao <i>h</i>:</p><ul><li><b>T√¨m ki·∫øm, th√™m, x√≥a:</b> O(h)</li><li><b>Tr∆∞·ªùng h·ª£p t·ªët nh·∫•t:</b> c√¢y c√¢n b·∫±ng ‚Üí h ‚âà log‚ÇÇ(n)</li><li><b>Tr∆∞·ªùng h·ª£p x·∫•u nh·∫•t:</b> c√¢y suy bi·∫øn th√†nh danh s√°ch li√™n k·∫øt ‚Üí h = n</li></ul><p>Do ƒë√≥, vi·ªác c√¢n b·∫±ng c√¢y (AVL, Red-Black Tree) gi√∫p duy tr√¨ hi·ªáu nƒÉng ·ªïn ƒë·ªãnh.</p><hr><h2>8. B√†i t·∫≠p luy·ªán t·∫≠p</h2><ol><li>Vi·∫øt h√†m ƒë·∫øm s·ªë node c·ªßa c√¢y BST.</li><li>Vi·∫øt h√†m t√≠nh ƒë·ªô cao c·ªßa c√¢y.</li><li>Vi·∫øt h√†m ƒë·∫øm s·ªë node l√°, node c√≥ 1 con, node c√≥ 2 con.</li><li>Vi·∫øt h√†m in c√°c node c√≥ gi√° tr·ªã ch·∫µn.</li><li>Vi·∫øt h√†m t√¨m ƒë∆∞·ªùng ƒëi t·ª´ g·ªëc ƒë·∫øn node c√≥ gi√° tr·ªã x.</li><li>Vi·∫øt h√†m t·∫°o BST t·ª´ d√£y s·ªë cho tr∆∞·ªõc.</li><li>Th·ª≠ nghi·ªám x√≥a node c√≥ 2 con v√† in l·∫°i k·∫øt qu·∫£ duy·ªát InOrder.</li></ol><hr><h2>‚úÖ T·ªïng k·∫øt</h2><p>C√¢y nh·ªã ph√¢n v√† ƒë·∫∑c bi·ªát l√† BST l√† n·ªÅn t·∫£ng cho nhi·ªÅu thu·∫≠t to√°n x·ª≠ l√Ω d·ªØ li·ªáu nhanh. Vi·ªác hi·ªÉu r√µ thao t√°c th√™m, x√≥a, duy·ªát v√† t√¨m ki·∫øm gi√∫p sinh vi√™n x√¢y d·ª±ng c√°c c·∫•u tr√∫c ph·ª©c t·∫°p h∆°n nh∆∞ AVL, Heap v√† Graph.</p>",
  "updated_at": null
}