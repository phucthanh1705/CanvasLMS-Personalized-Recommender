{
  "title": "BÀI 5 – TÍNH KẾ THỪA VÀ ĐA HÌNH",
  "created_at": "2025-10-19T12:54:03Z",
  "url": "bai-5-tinh-ke-thua-va-da-hinh",
  "editing_roles": "teachers",
  "page_id": 223,
  "last_edited_by": {
    "id": 1,
    "anonymous_id": "1",
    "display_name": "admin@gmail.com",
    "avatar_image_url": "http://localhost:3000/images/messages/avatar-50.png",
    "html_url": "http://localhost:3000/courses/4/users/1",
    "pronouns": null
  },
  "published": true,
  "hide_from_students": false,
  "front_page": false,
  "html_url": "http://localhost:3000/courses/4/pages/bai-5-tinh-ke-thua-va-da-hinh",
  "todo_date": null,
  "publish_at": null,
  "updated_at": "2025-10-19T12:54:19Z",
  "locked_for_user": false,
  "body": "<h1>BÀI 5 – TÍNH KẾ THỪA VÀ ĐA HÌNH</h1><h2>Mục tiêu học tập</h2><ul><li>Hiểu rõ khái niệm kế thừa (inheritance) và đa hình (polymorphism) trong OOP.</li><li>Phân biệt các loại kế thừa trong Java và nguyên lý Liskov Substitution.</li><li>Nắm vững kỹ thuật overriding, sử dụng từ khóa super và final hợp lý.</li><li>Áp dụng đa hình trong thiết kế chương trình hướng đối tượng.</li></ul><hr><h2>1. Tính kế thừa (Inheritance)</h2><p>Kế thừa cho phép lớp con (subclass) <b>kế thừa thuộc tính và hành vi</b> của lớp cha (superclass). Đây là cơ chế tái sử dụng mã và mở rộng chức năng.</p><pre><code>class Animal { void sound(){ System.out.println(\"Animal sound\"); } } class Dog extends Animal { void sound(){ System.out.println(\"Woof\"); } }</code></pre><p>Lớp <code>Dog</code> kế thừa từ <code>Animal</code> và ghi đè (override) phương thức sound().</p><ul><li><b>extends:</b> dùng để kế thừa lớp khác.</li><li><b>super:</b> gọi phương thức hoặc constructor của lớp cha.</li><li><b>final:</b> ngăn chặn kế thừa hoặc ghi đè.</li></ul><hr><h2>2. Các loại kế thừa</h2><ul><li><b>Đơn kế thừa (Single Inheritance):</b> một lớp chỉ kế thừa từ một lớp cha.</li><li><b>Đa cấp (Multilevel Inheritance):</b> A → B → C.</li><li><b>Phân cấp (Hierarchical Inheritance):</b> nhiều lớp con cùng kế thừa từ một lớp cha.</li><li><b>Đa kế thừa (Multiple):</b> không hỗ trợ trực tiếp trong Java (thay bằng interface).</li></ul><hr><h2>3. Từ khóa super và final</h2><pre><code>class Person { String name; Person(String name){ this.name = name; } } class Student extends Person { Student(String name){ super(name); } }</code></pre><p><code>super</code> dùng để gọi constructor hoặc phương thức lớp cha. <code>final</code> dùng để ngăn chặn override hoặc kế thừa.</p><pre><code>final class MathUtils {} // không thể kế thừa</code></pre><hr><h2>4. Overriding và Liskov Substitution</h2><p>Overriding cho phép lớp con thay đổi hành vi phương thức lớp cha nhưng giữ nguyên chữ ký. Theo nguyên lý LSP, lớp con phải có thể thay thế lớp cha mà không làm thay đổi hành vi mong đợi của chương trình.</p><pre><code>class Shape { double area(){ return 0; } } class Circle extends Shape { double r; Circle(double r){ this.r = r; } double area(){ return Math.PI * r * r; } }</code></pre><p>Overriding tuân thủ nguyên tắc:</p><ul><li>Giữ nguyên tên và danh sách tham số.</li><li>Kiểu trả về phải tương thích (covariant).</li><li>Có thể mở rộng phạm vi truy cập.</li></ul><hr><h2>5. Tính đa hình (Polymorphism)</h2><p>Đa hình cho phép cùng một phương thức có thể được gọi trên nhiều đối tượng khác nhau và cho kết quả khác nhau tùy theo loại thực tế của đối tượng.</p><pre><code>Shape s = new Circle(3); System.out.println(s.area()); // Gọi phương thức của Circle</code></pre><ul><li><b>Compile-time polymorphism:</b> nạp chồng (overloading).</li><li><b>Runtime polymorphism:</b> ghi đè (overriding).</li></ul><p>Cơ chế đa hình hoạt động dựa vào <b>dynamic dispatch</b> của JVM.</p><hr><h2>6. Quan hệ giữa kế thừa và interface</h2><p>Java không hỗ trợ đa kế thừa lớp, nhưng cho phép một lớp hiện thực nhiều interface.</p><pre><code>interface Flyable { void fly(); } class Bird implements Flyable { public void fly(){ System.out.println(\"Flying\"); } }</code></pre><hr><h2>7. Sử dụng abstract class và interface trong kế thừa</h2><p>Lớp trừu tượng cho phép định nghĩa khuôn mẫu chung, interface cho phép định nghĩa hợp đồng hành vi. Kết hợp cả hai để đạt tính linh hoạt và giảm coupling.</p><pre><code>abstract class Employee { abstract double calcSalary(); } class Developer extends Employee { double calcSalary(){ return 5000; } }</code></pre><hr><h2>8. Ví dụ tổng hợp</h2><pre><code>abstract class Vehicle { abstract void move(); } class Car extends Vehicle { void move(){ System.out.println(\"Car moving on road\"); } } class Airplane extends Vehicle { void move(){ System.out.println(\"Plane flying\"); } } public class Main { public static void main(String[] args){ Vehicle v1 = new Car(); Vehicle v2 = new Airplane(); v1.move(); v2.move(); } }</code></pre><hr><h2>Kết luận</h2><p>Kế thừa và đa hình là hai trụ cột quan trọng trong OOP. Kế thừa giúp tái sử dụng mã, đa hình giúp mở rộng linh hoạt hành vi. Thiết kế tốt cần đảm bảo tính thay thế (LSP) và tránh lạm dụng kế thừa sâu.</p>"
}