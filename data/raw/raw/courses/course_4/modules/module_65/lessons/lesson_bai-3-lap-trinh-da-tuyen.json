{
  "title": "BÀI 3 – LẬP TRÌNH ĐA TUYẾN",
  "created_at": "2025-10-25T13:28:54Z",
  "url": "bai-3-lap-trinh-da-tuyen",
  "editing_roles": "teachers",
  "page_id": 290,
  "last_edited_by": {
    "id": 1,
    "anonymous_id": "1",
    "display_name": "admin@gmail.com",
    "avatar_image_url": "http://localhost:3000/images/messages/avatar-50.png",
    "html_url": "http://localhost:3000/courses/4/users/1",
    "pronouns": null
  },
  "published": true,
  "hide_from_students": false,
  "front_page": false,
  "html_url": "http://localhost:3000/courses/4/pages/bai-3-lap-trinh-da-tuyen",
  "todo_date": null,
  "publish_at": null,
  "updated_at": "2025-10-25T13:29:09Z",
  "locked_for_user": false,
  "body": "<h1>⚙️ BÀI 3 – LẬP TRÌNH ĐA TUYẾN</h1><h2>3.1 GIỚI THIỆU</h2><p>Trong lập trình mạng, ứng dụng thường phải xử lý nhiều tác vụ đồng thời: đọc dữ liệu, gửi phản hồi, hiển thị giao diện, v.v. Vì vậy, Java cung cấp cơ chế <b>đa tuyến (multithreading)</b> để cho phép chương trình thực hiện song song nhiều công việc.</p><h3>3.1.1 Đơn tiến trình (Single-thread)</h3><p>Chương trình chỉ có một luồng thực thi duy nhất, thực hiện từng bước tuần tự. Nếu một tác vụ bị treo (ví dụ: chờ I/O), toàn bộ chương trình bị dừng.</p><h3>3.1.2 Đa tiến trình (Multi-thread)</h3><p>Chương trình có nhiều luồng (thread) chạy song song, chia sẻ tài nguyên nhưng hoạt động độc lập.</p><p>Ví dụ: một ứng dụng chat có thể có:</p><ul><li>1 luồng nhận tin nhắn</li><li>1 luồng gửi tin nhắn</li><li>1 luồng cập nhật giao diện</li></ul><h3>3.1.3 Tiến trình (Process)</h3><p>Tiến trình là một chương trình đang được thực thi. Mỗi tiến trình có không gian nhớ riêng, còn <b>Thread</b> chia sẻ vùng nhớ trong cùng một tiến trình.</p><hr><h2>3.2 LỚP THREAD</h2><p>Java cung cấp lớp <code>Thread</code> để tạo và quản lý luồng. Có hai cách khởi tạo:</p><ol><li>Kế thừa lớp <code>Thread</code>.</li><li>Cài đặt giao diện <code>Runnable</code>.</li></ol><h3>3.2.1 Tạo Thread</h3><pre><code>class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"Luồng đang chạy...\");\n    }\n}\n\npublic class TestThread {\n    public static void main(String[] args) {\n        MyThread t = new MyThread();\n        t.start(); // chạy luồng mới\n    }\n}</code></pre><p>Phương thức <code>start()</code> kích hoạt một luồng mới chạy song song với luồng chính.</p><h3>3.2.2 Chỉnh độ ưu tiên</h3><p>Mỗi luồng có độ ưu tiên (priority) từ 1 đến 10. Java định nghĩa ba hằng:</p><ul><li><code>Thread.MIN_PRIORITY</code> = 1</li><li><code>Thread.NORM_PRIORITY</code> = 5</li><li><code>Thread.MAX_PRIORITY</code> = 10</li></ul><pre><code>t1.setPriority(Thread.MAX_PRIORITY);</code></pre><h3>3.2.3 Thực thi và kết thúc Thread</h3><p>Phương thức <code>run()</code> chứa mã thực thi của luồng. Khi chạy xong, luồng tự kết thúc. Có thể tạm dừng luồng bằng:</p><ul><li><code>sleep(ms)</code>: tạm nghỉ.</li><li><code>join()</code>: chờ luồng khác hoàn tất.</li><li><code>isAlive()</code>: kiểm tra luồng còn chạy không.</li></ul><h3>3.2.4 Dừng Thread</h3><p>Luồng có thể kết thúc tự nhiên khi hoàn thành công việc hoặc được dừng bằng biến cờ (flag). Không nên dùng phương thức <code>stop()</code> vì có thể gây lỗi bộ nhớ.</p><pre><code>volatile boolean running = true;\npublic void run() {\n    while(running) {\n        // xử lý...\n    }\n}\npublic void stopThread() { running = false; }</code></pre><hr><h2>3.3 GIAO DIỆN RUNNABLE</h2><p>Cách phổ biến và an toàn hơn để tạo luồng là dùng giao diện <code>Runnable</code>:</p><pre><code>class Task implements Runnable {\n    public void run() {\n        System.out.println(\"Luồng Runnable đang chạy\");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        Thread t = new Thread(new Task());\n        t.start();\n    }\n}</code></pre><p>Cách này cho phép kế thừa từ lớp khác và dễ tái sử dụng hơn so với extends Thread.</p><hr><h2>3.4 ĐỒNG BỘ (SYNCHRONIZATION)</h2><p>Khi nhiều luồng cùng truy cập vào tài nguyên chung (file, biến toàn cục, socket...), có thể xảy ra xung đột dữ liệu. Java cung cấp cơ chế <b>synchronized</b> để đảm bảo chỉ một luồng được phép truy cập tại một thời điểm.</p><pre><code>class Counter {\n    private int count = 0;\n    public synchronized void increment() {\n        count++;\n    }\n}</code></pre><p>Từ khóa <code>synchronized</code> đảm bảo tính toàn vẹn dữ liệu (data consistency).</p><p>Đồng bộ có thể áp dụng cho:</p><ul><li>Phương thức</li><li>Khối lệnh</li></ul><pre><code>synchronized(obj) {\n    // đoạn mã an toàn\n}</code></pre><hr><h2>3.5 TRAO ĐỔI DỮ LIỆU GIỮA CÁC THREAD</h2><p>Các luồng có thể giao tiếp bằng biến chung, hàng đợi (queue) hoặc cơ chế chờ – thông báo (wait/notify).</p><pre><code>class Message {\n    private String content;\n    public synchronized void send(String msg) {\n        this.content = msg;\n        notify();\n    }\n    public synchronized String receive() throws InterruptedException {\n        wait();\n        return content;\n    }\n}</code></pre><p>→ Khi một luồng gọi <code>wait()</code>, nó tạm dừng cho đến khi luồng khác gọi <code>notify()</code>.</p><hr><h2>✅ TỔNG KẾT</h2><ul><li>Thread cho phép chương trình chạy song song nhiều công việc.</li><li>Dùng <code>Runnable</code> để tạo luồng linh hoạt hơn.</li><li><code>synchronized</code> đảm bảo dữ liệu an toàn trong đa luồng.</li><li><code>wait()</code> và <code>notify()</code> giúp các luồng phối hợp hiệu quả.</li></ul>"
}